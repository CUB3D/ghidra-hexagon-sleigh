# sleigh specification file for Skeleton Processor
#   >> see docs/languages/sleigh.htm or sleigh.pdf for Sleigh syntax
# Other language modules (see Ghidra/Processors) may provide better examples
# when creating a new language module.


# List of nice-to-haves in SELIGH
# arbitary bit-count sext, not just bytes
# allow sext and s>> in [] bit of constructor

define endian=little;
define alignment=4;

define space ram     type=ram_space      size=4 wordsize=1 default;
define space register type=register_space size=4;

define token instr64 (64)
    # imm64 = second word
    # immw = first word
   parsew = (14, 15)
   parse64 = (46, 48)
   iclass64     = (60,63)
   
   imm64_27 = (27, 27)

   imm64_25_26 = (25, 26) signed

   imm64_22_23 = (54, 55)

   imm64_21_24 = (21, 24)
   imm64_21 = (53, 53)

   imm64_16_20 = (48, 52)

   imm64_5_13 = (37, 45) signed

   Rs64 = (59, 59)
   MajOp64 = (56,58)

   S564 = (16,20)
   D564 = (32,36)

   iclassw = (28, 31)
;

define token instr13 (13)

	immdup_13=(13,13)
	immdup_9_12=(9,12)
	immdup_5_8=(5,8)
	immdup_0_9=(0,9)
	immdup_0_4=(0,4)
;

define token instr (32)
   iclass     = (28,31)

   imm_29_31 = (29, 31)

   imm_27 = (27, 27)

   imm_25_27 = (25, 27)
   imm_25_26 = (25, 26) signed

   imm_24_27 = (24, 27)

   imm_23_27 = (23, 27)
   imm_23_24 = (23, 24)
   imm_23 = (23, 23)

   imm_22_27 = (22, 27)
   imm_22_23 = (22, 23)
   imm_22 = (22, 22)

   imm_21_27 = (21, 27) signed
   imm_21_24 = (21, 24)
   imm_21_23 = (21, 23)
   imm_21_22 = (21, 22)
   imm_21 = (21, 21) signed

   imm_20_27 = (20, 27)
   imm_20_21 = (20, 21)

   imm_18_21 = (18, 21)
   imm_18_20 = (18, 20)
   imm_18_19 = (18, 19)

   imm_16_27 = (16, 27)
   imm_16_25 = (16, 25)
   imm_16_24 = (16, 24) signed
   imm_16_23 = (16, 23)
   imm_16_22 = (16, 22)
   imm_16_21 = (16, 21)
   imm_16_20 = (16, 20)
   imm_16_17 = (16, 17)

   imm_13 = (13, 13) signed

   imm_12_13 = (12, 13)
   imm_12 = (12, 12)

   imm_11_13 = (11, 13)
   imm_11_12 = (11, 12)
   imm_11 = (11, 11)

   imm_10_13 = (10, 13)
   imm_10_12 = (10, 12)
   imm_10 = (10, 10)

   imm_9_10 = (9, 10)

   imm_8_13 = (8, 13)
   imm_8_12 = (8, 12)
   imm_8 = (8, 8)

   imm_7_13 = (7, 13)
   imm_7_12 = (7, 12)
   imm_7 = (7, 7)

   imm_6_13 = (6, 13)
   imm_6 = (6, 6)

   imm_5_13 = (5, 13) signed
   imm_5_12 = (5, 12)
   imm_5_10 = (5, 10)
   imm_5_9 = (5, 9)
   imm_5_8 = (5, 8)
   imm_5_7 = (5, 7)
   imm_5_6 = (5, 6)

   imm_4 = (4, 4)

   imm_3_12 = (3, 12)
   imm_3_6 = (3, 6)
   imm_3_4 = (3, 4)
   imm_3 = (3, 3)

   imm_2_13 = (2, 13)
   imm_2_12 = (2, 12)
   imm_2_7 = (2, 7)
   imm_2_6 = (2, 6)
   imm_2_5 = (2, 5)
   imm_2_4 = (2, 4)
   imm_2_3 = (2, 3)
   imm_2 = (2, 2)

   imm_1_13 = (1, 13) signed
   imm_1_7 = (1, 7)
   imm_1_2 = (1, 2)
   imm_1 = (1, 1)

   imm_0_13 = (0, 13)
   imm_0_10 = (0, 10)
   imm_0_9 = (0, 9)
   imm_0_7 = (0, 7) signed
   imm_0_6 = (0, 6)
   imm_0_5 = (0, 5)
   imm_0_4 = (0, 4)
   imm_0_2 = (0, 2)
   imm_0_1 = (0, 1)
   imm_0 = (0, 0)
   

   D4_16_19 = (16,19)
   D4_8_11 = (8,11)
   S4 = (16,19)
   S2 = (16,17)
   T2 = (8,9)
   D2 = (0,1)

   S2_pred = (16,17)
   T2_pred = (8,9)
   D2_pred = (0,1)
   U2_pred = (8,9)

   T5 = (8,12)
   
   
   Rs = (27, 27)
   MajOp = (24,26)
   MinOp = (21,23)
   D7 = (0,7)
   D7_svctrl = (0,7)
   D5 = (0,4)
   D5_ctrl = (0,4)
   S7 = (16,22)
   S7_svctrl = (16,22)
   S5 = (16,20)
   S5_ctrl = (16,20)
   alu_X5 = (16,20)
   U2 = (8,9)
   
   parse = (14, 15)
  	imm32 = (0, 31)
;

define register offset=0x00 size=4 [ 
X0 
X1 
X2 
X3 
X4 
X5 
X6 
X7 
X8 
X9 
X10 
X11 
X12 
X13 
X14 
X15 
X16 
X17 
X18 
X19 
X20 
X21 
X22 
X23 
X24 
X25 
X26 
X27 
X28 
SP
FP
LR
 ];

attach variables [ D5 S5 alu_X5 T5 ] [
X0 
X1 
X2 
X3 
X4 
X5 
X6 
X7 
X8 
X9 
X10 
X11 
X12 
X13 
X14 
X15 
X16 
X17 
X18 
X19 
X20 
X21 
X22 
X23 
X24 
X25 
X26 
X27 
X28 
SP
FP
LR
];

attach variables [ S4 D4_16_19 D4_8_11 ] [
X0 
X1 
X2 
X3 
X4 
X5 
X6 
X7 
X16 
X17 
X18 
X19 
X20 
X21 
X22 
X23 
];

 define register offset=0x80 size=4 [ 
SA0
LC0
SA1
LC1
P30
Reserve_5
M0
M1
USR
PC
UGP
GP
CS0
CS1
UPCYCLELO
UPCYCLEHI

Reserved_16
Reserved_17
Reserved_18
Reserved_19
Reserved_20
Reserved_21
Reserved_22
Reserved_23
Reserved_24
Reserved_25
Reserved_26
Reserved_27
Reserved_28
Reserved_29
Reserved_30
Reserved_31
 ];

 
 attach variables [ D5_ctrl S5_ctrl ] [
 SA0
LC0
SA1
LC1
P30
Reserve_5
M0
M1
USR
PC
UGP
GP
CS0
CS1
UPCYCLELO
UPCYCLEHI

Reserved_16
Reserved_17
Reserved_18
Reserved_19
Reserved_20
Reserved_21
Reserved_22
Reserved_23
Reserved_24
Reserved_25
Reserved_26
Reserved_27
Reserved_28
Reserved_29
Reserved_30
Reserved_31
];

define register offset=0x100 size=4 [ 
P0
P1
P2
P3
];
attach variables [ U2 D2_pred T2_pred S2_pred U2_pred ] [
P0
P1
P2
P3
];


Addr32i:  is    imm_16_24 & imm_1_13 {


	local loc:4 = (((imm_16_24 << 13) | (imm_1_13)) << 2);
	local loc1:3 = loc:3;
	local loc2:4 = sext(loc1);

	local loc3:4 = loc2 + inst_start;
 export *:4 loc3;
  }



 define pcodeop _stub;

 
# ALU32/ALU:add
slot:D5" = add("S5",#"loc")" is iclass=0b1011 & S5 & D5 & imm_21_27 & imm_5_13 [loc= ((imm_21_27 << 9) | (imm_5_13));] {
    D5 = S5 + sext(loc:2);
} 
slot:D5" = add("S5","T5")" is iclass=0b1111 & D5 & imm_21_27=0b0011000 & S5 & imm_13=0 & T5 & imm_5_7=0 {
    D5 = S5 + T5;
} 
slot:D5" = add("S5","T5"):sat" is iclass=0b1111 & D5 & imm_21_27=0b0110010 & S5 & imm_13=0 & T5 & imm_5_7=0 {
    #D5 = S5 + T5;
    _stub();
} 

# ALU32/ALU:logical
with slot: iclass=0b0111 {
	:D5 = "and"(S5,#s10) is Rs=0 & MajOp = 0b110 & imm_22_23=0b00 & imm_21 & S5 & imm_5_13 & D5 [ s10 = (imm_21 << 9) | imm_5_13;] {
		D5 = S5 & s10;
	} 

	:D5 = "or"(S5,#s10) is Rs=0 & MajOp = 0b110 & imm_22_23=0b10 & imm_21 & S5 & imm_5_13 & D5 [ s10 = (imm_21 << 9) | imm_5_13;] {
		D5 = S5 & s10;
	} 
}
with slot: iclass=0b1111 {
	:D5 = "and("S5","T5")" is imm_21_27=0b0001000 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = S5 & T5;
	} 

	:D5 = "or("S5","T5")" is imm_21_27=0b0001001 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = S5 | T5;
	} 

	:D5 = "xor("S5","T5")" is imm_21_27=0b0001011 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = S5 ^ T5;
	} 

	:D5 = "and("T5",~"S5")" is imm_21_27=0b0001100 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = T5 & (~S5);
	} 

	:D5 = "or("T5",~"S5")" is imm_21_27=0b0001101 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = T5 | (~S5);
	} 
}
# ALU32/ALU:negate
# TODO

# ALU32/ALU:nop
with slot: iclass=0b0111 {
	:"nop" is imm_24_27=0b1111 & imm_16_23  & imm_0_13 {}
}

# ALU32/ALU:subtract
with slot: iclass=0b0111 {
	slot:" = sub()" is imm_22_27=0b011001 & imm_21 & S5 & imm_5_13 & D5 {
		_stub();
	} 
}
with slot: iclass=0b1111 {
	slot:D5" = sub("T5","S5")" is imm_21_27=0b0011001 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
	    D5 = T5 - S5;
	} 

	slot:D5" = sub("T5","S5"):sat" is imm_21_27=0b0110110 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		_stub();
	    #D5 = T5 - S5;
	} 
}


# ALU32/ALU:sext
with slot: iclass=0b0111 {
	slot:D5" = sxtb("S5")" is imm_21_27=0b0000101 & S5 & imm_13=0 & imm_5_12=0 & D5 {
	_stub();
	} 
	slot:D5" = sxth("S5")" is imm_21_27=0b0000111 & S5 & imm_13=0 & imm_5_12=0 & D5 {
	_stub();
	} 
}

# ALU32/ALU:trans_imm
 with slot: iclass=0b0111 {
  	
	ImmU16: v is    imm_22_23 & imm_0_13  [ v = (imm_22_23 << 13) | (imm_0_13); ] {
		local v1:4 = v;
	 	export v1;
	  }
	  
  	TI_S16: v is    imm_22_23 & imm_16_20 & imm_5_13  [ v = (imm_5_13) | (imm_16_20 << 9) | (imm_22_23 << 14); ] {
		local v1:4 = v;
	 	export v1;
	  }
	  
 
	:alu_X5^".L" = ImmU16 is Rs = 0 & MajOp = 0b001 & imm_21=1 & alu_X5 & ImmU16 {
		local tmp:4 = alu_X5 & 0xFFFF0000;
		alu_X5 = tmp | ImmU16;
	}
	
	:alu_X5^".H" = ImmU16 is Rs = 0 & MajOp = 0b010 & imm_21=1 & alu_X5 & ImmU16 {
		local tmp:4 = alu_X5 & 0x0000FFFF;
		alu_X5 = tmp | (ImmU16 << 16);
	}
	
	:D5=TI_S16 is  Rs = 1 & MajOp=0b000 & imm_21=0 & TI_S16 & D5 {
		D5 = TI_S16;
	}  
}
# Special case for constant extender
wslot:"extD5=num" is iclass64=0b0111 & Rs64=1 & MajOp64=0b000 & imm64_21=0 &  D564 & imm64_22_23 & imm64_16_20 & imm64_5_13
{
_stub();
}
# Special case for const extender
#wslot:"CEXT:"D5"="TI_S16 is iclass=0b0000; iclass=0b0111 & Rs = 1 & MajOp=0b000 & imm_21=0 & TI_S16 & D5 {
#    D5 = TI_S16;
#}  


# ALU32/ALU:trans_reg
 with slot: iclass=0b0111 {

    # Transfer register
	:D5"="S5 is Rs = 0 & MajOp = 0b000 & MinOp=0b011 & S5 & imm_13=0 & imm_5_12=0 & D5 {
        D5 = S5;
	}
}


# ALU32/ALU:vechw
# ALU32/ALU:vecahw
# ALU32/ALU:vecshw

# ALU32/ALU:zext
 with slot: iclass=0b0111 {
	:D5"="S5 is imm_21_27=0b0000110 & S5 & imm_13=0 & imm_5_12=0 & D5 {
	_stub();
	}
}

# ALU32/PERM:Combine words
with slot: iclass=0b0111 {
    :D5="comb0(" is Rs=0 & MajOp=0b011 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=1 & imm_5_12 & D5 {
        _stub();
    }
    :D5="comb1(" is Rs=0 & MajOp=0b011 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=1 & imm_5_12 & D5 {
        _stub();
    }
    :D5="comb2(" is Rs=1 & MajOp=0b100 & imm_23=0 & imm_16_22 & imm_13 & imm_5_12 & D5 {
        _stub();
    }
    :D5="comb3(" is Rs=1 & MajOp=0b100 & imm_23=1 & imm_21_22=0 & imm_16_20 & imm_13 & imm_5_12 & D5 {
        _stub();
    }
}
with slot: iclass=0b1111 {
    :D5="comb4(" is Rs=0 & MajOp=0b011 & MinOp=0b100 & S5 & imm_13 & T5 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="comb5(" is Rs=0 & MajOp=0b011 & MinOp=0b101 & S5 & imm_13 & T5 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="comb6(" is Rs=0 & MajOp=0b011 & MinOp=0b110 & S5 & imm_13 & T5 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="comb7(" is Rs=0 & MajOp=0b011 & MinOp=0b111 & S5 & imm_13 & T5 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="comb8(" is Rs=0 & MajOp=0b101 & imm_23=0 & imm_21_22=0 & S5 & imm_13 & T5 & imm_5_7=0 & D5 {
        _stub();
    }
}

# ALU32/PERM:Mux
with slot: iclass=0b0111 {
    :D5="mux0(" is Rs=0 & MajOp=0b011 & imm_23=0 & imm_21_22 & S5 & imm_13=0 & imm_5_12 & D5 {
        _stub();
    }
    :D5="mux1(" is Rs=0 & MajOp=0b011 & imm_23=1 & imm_21_22 & S5 & imm_13=0 & imm_5_12 & D5 {
        _stub();
    }
    :D5="mux2(" is Rs=1 & imm_25_26=0b01 & imm_23_24 & imm_16_22 & imm_13 & imm_5_12 & D5 {
        _stub();
    }
}
with slot: iclass=0b1111 {
    :D5="mux3(" is Rs=0 & MajOp=0b100 & imm_21_23 & S5 & imm_13=0 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
}

# ALU32/PERM:Shift word 16
with slot: iclass=0b0111 {
    :D5="aslh(" is Rs=0 & MajOp=0b000 & MinOp=0b000 & S5 & imm_13=0 & imm_5_12=0 & D5 {
        _stub();
    }
    :D5="asrh(" is Rs=0 & MajOp=0b000 & MinOp=0b001 & S5 & imm_13=0 & imm_5_12=0 & D5 {
        _stub();
    }
}

# ALU32/PERM:Pack hi and lo hw
with slot: iclass=0b1111 {
    :D5="packhl(" is Rs=0 & MajOp=0b101 & imm_23=1 & imm_21_22=0 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
        _stub();
    }
}

# ALU32/PRED:Compare add
with slot: iclass=0b0111 {
    :D5="cadd0(" is Rs=0 & MajOp=0b100 & imm_23=0 & imm_21_22 & S5 & imm_13=0 & imm_5_12 & D5 {
        _stub();
    }
    :D5="cadd1(" is Rs=0 & MajOp=0b100 & imm_23=0 & imm_21_22 & S5 & imm_13=1 & imm_5_12 & D5 {
        _stub();
    }
    :D5="cadd2(" is Rs=0 & MajOp=0b100 & imm_23=1 & imm_21_22 & S5 & imm_13=0 & imm_5_12 & D5 {
        _stub();
    }
    :D5="cadd3(" is Rs=0 & MajOp=0b100 & imm_23=1 & imm_21_22 & S5 & imm_13=1 & imm_5_12 & D5 {
        _stub();
    }
}
with slot: iclass=0b1111 {
    :D5="cadd4(" is Rs=1 & MajOp=0b011 & imm_23=0 & imm_21=0 & imm_21=0 & S5 & imm_13=0 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="cadd5(" is Rs=1 & MajOp=0b011 & imm_23=0 & imm_21=0 & imm_21=0 & S5 & imm_13=0 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }
    :D5="cadd6(" is Rs=1 & MajOp=0b011 & imm_23=0 & imm_21=0 & imm_21=0 & S5 & imm_13=1 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    } 
    :D5="cadd7(" is Rs=1 & MajOp=0b011 & imm_23=0 & imm_21=0 & imm_21=0 & S5 & imm_13=1 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    } 
}
# ALU32/PRED:Cond shift hw
with slot: iclass=0b0111 {
    :D5="cshw0(" is Rs=0 & MajOp=0b000 & MinOp=0b000 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b00 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="cshw1(" is Rs=0 & MajOp=0b000 & MinOp=0b000 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b01 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="cshw2(" is Rs=0 & MajOp=0b000 & MinOp=0b000 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b10 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="cshw3(" is Rs=0 & MajOp=0b000 & MinOp=0b000 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b11 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }

    :D5="cshw4(" is Rs=0 & MajOp=0b000 & MinOp=0b001 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b00 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="cshw5(" is Rs=0 & MajOp=0b000 & MinOp=0b001 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b01 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="cshw6(" is Rs=0 & MajOp=0b000 & MinOp=0b001 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b10 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }
    :D5="cshw7(" is Rs=0 & MajOp=0b000 & MinOp=0b001 & S5 & imm_13=1 & imm_12_0 & imm_10_11=0b11 & imm_8_9 & imm_5_7=0 & D5 {
        _stub();
    }
}

# ALU32/PRED:Cond comb
with slot: iclass=0b1111 {
    :D5="ccmb0(" is Rs=1 & MajOp=0b101 & MinOp=0b000 & S5 & imm_13=0 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="ccmb1(" is Rs=1 & MajOp=0b101 & MinOp=0b000 & S5 & imm_13=0 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }
    :D5="ccmb2(" is Rs=1 & MajOp=0b101 & MinOp=0b000 & S5 & imm_13=1 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="ccmb3(" is Rs=1 & MajOp=0b101 & MinOp=0b000 & S5 & imm_13=1 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }
}
# ALU32/PRED:Cond logical
with slot: iclass=0b1111 {
    :D5="clo0("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo1("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo2("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=1 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo3("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=1 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }

    :D5="clo4("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo5("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo6("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=1 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo7("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=1 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }

    :D5="clo8("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b11 & S5 & imm_13=0 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo9("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b11 & S5 & imm_13=0 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo10("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b11 & S5 & imm_13=1 & T5 & imm_7=0 & imm_5_6 & D5 {
        _stub();
    }
    :D5="clo11("S5")" is Rs=1 & MajOp=0b001 & imm_23=0 & imm_21_22=0b11 & S5 & imm_13=1 & T5 & imm_7=1 & imm_5_6 & D5 {
        _stub();
    }
}
# ALU32/PRED:Cond sub
# ALU32/PRED:sext
# ALU32/PRED:trans
# ALU32/PRED:zext
# ALU32/PRED:cmp

 with slot: iclass=0b0111 {
    # Compare
	:D2_pred="cmp.eq("S5", "s10")" is Rs = 0 & MajOp=0b101 & imm_22_23=0b00 & imm_21 & S5 & imm_5_13 & imm_2_4=0b000 & D2_pred [s10 = imm_5_13 | (imm_21 << 9);] {
        if( S5 == s10) goto <good>;
        D2_pred = -1;
        goto inst_next;
        <good>
        D2_pred = 0;
        goto inst_next;
	}  

}
# ALU32/PRED:cmp gen

# CR:end loop
# CR: Corner detection
with slot: iclass=0b0110 {
    slot:"fastcorner9" is imm_20_27=0b10110000 & imm_18_19=0b00 & S2 & imm_13=1 & imm_10_12=0b000 & T2 & imm_7=1 & imm_5_6=0b00 & imm_4=1 & imm_2_3=0b00 & D2 {
        _stub();
    }
    slot:"!fastcorner9" is imm_20_27=0b10110001 & imm_18_19=0b00 & S2 & imm_13=1 & imm_10_12=0b000 & T2 & imm_7=1 & imm_5_6=0b00 & imm_4=1 & imm_2_3=0b00 & D2 {
        _stub();
    }
}
# CR: Logical reduction
with slot: iclass=0b0110 {
    slot:"all8" is imm_20_27=0b10111000 & imm_18_19=0b00 & S2 & imm_13=0 & imm_2_12=0 & D2 {
        _stub();
    }
    slot:"any8" is imm_20_27=0b10111010 & imm_18_19=0b00 & S2 & imm_13=0 & imm_2_12=0 & D2 {
        _stub();
    }
}

# CR: Looops
with slot: iclass=0b0110 {
    slot:"loop0" is imm_21_27=0b0000000 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2=0 {
        _stub();
    }
    slot:"loop1" is imm_21_27=0b0000001 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2=0 {
        _stub();
    }
    slot:"loop0_" is imm_21_27=0b1001000 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2=0 {
        _stub();
    }
    slot:"loop1_" is imm_21_27=0b1001001 & S5 & imm_13=0 & imm_3_12 & imm_2=0 & imm_0_1  {
        _stub();
    }
}

# CR:Pc add
with slot: iclass=0b0110 {
    :"pcadd" is imm_16_27=0b101001001001 & imm_13=0 & imm_7_12 & imm_5_6=0 & D5 {
        _stub();
    }
}

# CR:Pipelined loop
with slot: iclass=0b0110 {
    :"sp1loop0" is imm_21_27=0b0000101 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2 {
        _stub();
    }
    :"sp2loop0" is imm_21_27=0b0000110  & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2 {
        _stub();
    }
    :"sp3loop0" is imm_21_27=0b0000111  & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2 {
        _stub();
    }

    :"sp1loop01" is imm_21_27=0b1001101 & imm_16_20 & imm_13=0 & imm_3_12 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"sp2loop01" is imm_21_27=0b1001110 & imm_16_20 & imm_13=0 & imm_3_12 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"sp2loopw1" is imm_21_27=0b1001111 & imm_16_20 & imm_13=0 & imm_3_12 & imm_2=0 & imm_0_1 {
        _stub();
    }
}


#CR: Logical predicates 
with slot: iclass=0b0110 {
    :D2_pred"=and("T2_pred", "S2_pred")" is imm_20_27=0b10110000 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred & S2_pred;
    }

    :D2_pred"=and("S2_pred", and("T2_pred","U2_pred"))" is imm_20_27=0b10110001 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & T2_pred & U2_pred;
    }

    :D2_pred"=or("T2_pred", "S2_pred")" is imm_20_27=0b10110010 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred | S2_pred;
    }

    :D2_pred"=and("S2_pred", or("T2_pred","U2_pred"))" is imm_20_27=0b10110011 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred | U2_pred);
    }

    :D2_pred"=xor("T2_pred", "S2_pred")" is imm_20_27=0b10110100 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred ^ S2_pred;
    }

    :D2_pred"=or("S2_pred", and("T2_pred","U2_pred"))" is imm_20_27=0b10110101 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred | U2_pred);
    }

    :D2_pred"=and("T2_pred", !"S2_pred")" is imm_20_27=0b10110110 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred & (~S2_pred);
    }

    :D2_pred"=or("S2_pred", or("T2_pred","U2_pred"))" is imm_20_27=0b10110111 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred | (T2_pred | U2_pred);
    }

    :D2_pred"=and("S2_pred", and("T2_pred", !"U2_pred"))" is imm_20_27=0b10111001 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred & ~U2_pred);
    }

    :D2_pred"=and("S2_pred", or("T2_pred", !"U2_pred"))" is imm_20_27=0b10111011 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred | ~U2_pred);
    }

    :D2_pred"=not("S2_pred")" is imm_20_27=0b10111100 & imm_18_19=0 & S2_pred & imm_13=0 & imm_2_12=0 & D2_pred {
        D2_pred = ~S2_pred;
    }

    :D2_pred"=or("S2_pred", and("T2_pred", !"U2_pred"))" is imm_20_27=0b10111101 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred | (T2_pred & ~U2_pred);
    }

    :D2_pred"=or("T2_pred", !"S2_pred")" is imm_20_27=0b10111110 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred | ~S2_pred;
    }

    :D2_pred"=or("S2_pred", or("T2_pred", !"U2_pred"))" is imm_20_27=0b10111111 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred | (T2_pred | ~U2_pred);
    }

    # User control register transfer
    : D5_ctrl = S5 is imm_21_27=0b0010001 & S5 & imm_5_13=0 & D5_ctrl {
        D5_ctrl = S5;
    }
    slot: "D5_ctrl = S5 (dd/ss)" is imm_21_27=0b0011001 & S5_ctrl & imm_5_13=0 & D5 {
        _stub();
        #D5 = S5_ctrl;
    }
    slot: "D5 = S5_ctrl (dd/ss)" is imm_21_27=0b1000000 & S5_ctrl & imm_5_13=0 & D5 {
        _stub();
        #D5 = S5_ctrl;
    }
    slot: D5 = S5_ctrl is imm_21_27=0b1010000 & S5_ctrl & imm_5_13=0 & D5 {
        D5 = S5_ctrl;
    }
}

 # JR
 define pcodeop hintjr;
 with slot: iclass=0b0101 {
    # JR

    # call from reg
	 slot:"callr" S5 is imm_21_27=0b0000101 & S5 & imm_0_13=0b00000000000000 {
         _stub();
	 }

	 slot:"if ("U2") callr" S5 is imm_21_27=0b0001000 & S5 & imm_10_13=0 & U2 & imm_0_7=0 {
         _stub();
	 }
	 slot:"if (!"U2") callr" S5 is imm_21_27=0b0001001 & S5 & imm_10_13=0 & U2 & imm_0_7=0 {
         _stub();
	 }

     # Hint indirect jmp
	 slot:"hintjr("S5")" is imm_21_27=0b0010101 & S5 & imm_0_13=0b00000000000000 {
        hintjr(S5);
	 }


    # Jump to addr from reg
	 slot:"jumpr" S5 is imm_21_27=0b0010100 & S5 & imm_0_13=0b00000000000000 {
		goto [S5];
	 }

	 slot:"if("U2") jumpr:nt "S5 is imm_21_27=0b0011010 & S5 & imm_13=0 & imm_11_12=0b00 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
	 slot:"if("U2".new) jumpr:nt "S5 is imm_21_27=0b0011010 & S5 & imm_13=0 & imm_11_12=0b01 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
	 slot:"if("U2") jumpr:t "S5 is imm_21_27=0b0011010 & S5 & imm_13=0 & imm_11_12=0b10 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
	 slot:"if("U2".new) jumpr:t "S5 is imm_21_27=0b0011010 & S5 & imm_13=0 & imm_11_12=0b11 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
	 slot:"if(!"U2") jumpr:nt "S5 is imm_21_27=0b0011011 & S5 & imm_13=0 & imm_11_12=0b00 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
	 slot:"if(!"U2".new) jumpr:nt "S5 is imm_21_27=0b0011011 & S5 & imm_13=0 & imm_11_12=0b01 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
	 slot:"if(!"U2") jumpr:t "S5 is imm_21_27=0b0011011 & S5 & imm_13=0 & imm_11_12=0b10 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
	 slot:"if(!"U2".new) jumpr:t "S5 is imm_21_27=0b0011011 & S5 & imm_13=0 & imm_11_12=0b11 & imm_10=0 & U2 & imm_0_7=0 {
        _stub();
	 }
 }


# J
with slot: iclass=0b0101 {
     # Call subroutine
    Call_R22: is imm_16_25 & imm_1_13 {
        local loc:4 = (((imm_16_25 << 13) | (imm_1_13)) << 2);
        local loc1:3 = loc:3;
        local loc2:4 = sext(loc1);

        local loc3:4 = inst_start + loc2;
        export  loc3;
      }
	 slot:"call" Call_R22 is imm_25_27=0b101 & Call_R22 & imm_0=0 {
        LR = inst_next;
        call [Call_R22];
	 }

	 slot:"if ("U2") call num" is imm_24_27=0b1101 & imm_22_23 & imm_21=0 & imm_16_20 & imm_13 & imm_12=0 & imm_11=0 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }

	 slot:"if (!"U2") call num" is imm_24_27=0b1101 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_12=0 & imm_11=0 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
 }

#J:Compare and jump
 with slot: iclass=0b0001 {
     :"cj0 " is imm_27=0 & imm_22_26=0b00110 & imm_20_21 & S4 & imm_13=0 & iimm_10_12 & imm_8_9=0b00 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj1 " is imm_27=0 & imm_22_26=0b00110 & imm_20_21 & S4 & imm_13=0 & iimm_10_12 & imm_8_9=0b01 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj2 " is imm_27=0 & imm_22_26=0b00110 & imm_20_21 & S4 & imm_13=0 & iimm_10_12 & imm_8_9=0b11 & imm_1_7 & imm_0=0{
        
     _stub();
     }

     :"cj3 " is imm_27=0 & imm_22_26=0b00110 & imm_20_21 & S4 & imm_13=1 & iimm_10_12 & imm_8_9=0b00 & imm_1_7 & imm_0=0{
        
     _stub();
     }
     :"cj4 " is imm_27=0 & imm_22_26=0b00110 & imm_20_21 & S4 & imm_13=1 & iimm_10_12 & imm_8_9=0b01 & imm_1_7 & imm_0=0{
        
     _stub();
     }
     :"cj5 " is imm_27=0 & imm_22_26=0b00110 & imm_20_21 & S4 & imm_13=1 & iimm_10_12 & imm_8_9=0b11 & imm_1_7 & imm_0=0{
        
     _stub();
     }

     :"cj6 " is imm_27=0 & imm_22_26=0b00111 & imm_20_21 & S4 & imm_13=0 & iimm_10_12 & imm_8_9=0b00 & imm_1_7 & imm_0=0{
        
     _stub();
     }
     :"cj7 " is imm_27=0 & imm_22_26=0b00111 & imm_20_21 & S4 & imm_13=0 & iimm_10_12 & imm_8_9=0b01 & imm_1_7 & imm_0=0{
        
     _stub();
     }
     :"cj8 " is imm_27=0 & imm_22_26=0b00111 & imm_20_21 & S4 & imm_13=0 & iimm_10_12 & imm_8_9=0b11 & imm_1_7 & imm_0=0{
        
     _stub();
     }
#np
     :"cj9 " is imm_27=0 & imm_22_26=0b00111 & imm_20_21 & S4 & imm_13=1 & iimm_10_12 & imm_8_9=0b00 & imm_1_7 & imm_0=0{
        
     _stub();
     }
     :"cj10 " is imm_27=0 & imm_22_26=0b00111 & imm_20_21 & S4 & imm_13=1 & iimm_10_12 & imm_8_9=0b01 & imm_1_7 & imm_0=0{
        
     _stub();
     }
     :"cj11 " is imm_27=0 & imm_22_26=0b00111 & imm_20_21 & S4 & imm_13=1 & iimm_10_12 & imm_8_9=0b11 & imm_1_7 & imm_0=0{
        
     _stub();
     }

     :"cj12 " is imm_27=0 & imm_22_26=0b00000 & imm_20_21 & S4 & imm_13=0 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj13 " is imm_27=0 & imm_22_26=0b00000 & imm_20_21 & S4 & imm_13=1 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj14 " is imm_27=0 & imm_22_26=0b00001 & imm_20_21 & S4 & imm_13=0 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }

     :"cj15 " is imm_27=0 & imm_22_26=0b00001 & imm_20_21 & S4 & imm_13=1 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj16 " is imm_27=0 & imm_22_26=0b00010 & imm_20_21 & S4 & imm_13=0 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj17 " is imm_27=0 & imm_22_26=0b00010 & imm_20_21 & S4 & imm_13=1 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj18 " is imm_27=0 & imm_22_26=0b00011 & imm_20_21 & S4 & imm_13=0 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj19 " is imm_27=0 & imm_22_26=0b00011 & imm_20_21 & S4 & imm_13=1 & iimm_8_12 & imm_1_7 & imm_0=0 {
        
     _stub();
     }
     :"cj20 " is imm_27=0 & imm_22_26=0b00100 & imm_20_21 & S4 & imm_13=0 & iimm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj21 " is imm_27=0 & imm_22_26=0b00100 & imm_20_21 & S4 & imm_13=1 & iimm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj22 " is imm_27=0 & imm_22_26=0b00101 & imm_20_21 & S4 & imm_13=0 & iimm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj23 " is imm_27=0 & imm_22_26=0b00101 & imm_20_21 & S4 & imm_13=1 & iimm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }

     :"cj24 " is imm_27=0 & imm_22_26=0b01110 & imm_20_21 & S4 & imm_13=0 & imm_10_12=0 & imm_8_9=0b00 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj25 " is imm_27=0 & imm_22_26=0b01110 & imm_20_21 & S4 & imm_13=0 & imm_10_12=0 & imm_8_9=0b01 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj26 " is imm_27=0 & imm_22_26=0b01110 & imm_20_21 & S4 & imm_13=0 & imm_10_12=0 & imm_8_9=0b11 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj27 " is imm_27=0 & imm_22_26=0b01110 & imm_20_21 & S4 & imm_13=1 & imm_10_12=0 & imm_8_9=0b00 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj28 " is imm_27=0 & imm_22_26=0b01110 & imm_20_21 & S4 & imm_13=1 & imm_10_12=0 & imm_8_9=0b01 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj29 " is imm_27=0 & imm_22_26=0b01110 & imm_20_21 & S4 & imm_13=1 & imm_10_12=0 & imm_8_9=0b11 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj30 " is imm_27=0 & imm_22_26=0b01111 & imm_20_21 & S4 & imm_13=0 & imm_10_12=0 & imm_8_9=0b00 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj31 " is imm_27=0 & imm_22_26=0b01111 & imm_20_21 & S4 & imm_13=0 & imm_10_12=0 & imm_8_9=0b01 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj32 " is imm_27=0 & imm_22_26=0b01111 & imm_20_21 & S4 & imm_13=0 & imm_10_12=0 & imm_8_9=0b11 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj33 " is imm_27=0 & imm_22_26=0b01111 & imm_20_21 & S4 & imm_13=1 & imm_10_12=0 & imm_8_9=0b00 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj34 " is imm_27=0 & imm_22_26=0b01111 & imm_20_21 & S4 & imm_13=1 & imm_10_12=0 & imm_8_9=0b01 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj35 " is imm_27=0 & imm_22_26=0b01111 & imm_20_21 & S4 & imm_13=1 & imm_10_12=0 & imm_8_9=0b11 & imm_1_7 & imm_0=0 {
	     _stub();
     }


     :"cj36 " is imm_27=0 & imm_22_26=0b01000 & imm_20_21 & S4 & imm_13=0 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj37 " is imm_27=0 & imm_22_26=0b01000 & imm_20_21 & S4 & imm_13=1 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj38 " is imm_27=0 & imm_22_26=0b01001 & imm_20_21 & S4 & imm_13=0 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj39 " is imm_27=0 & imm_22_26=0b01001 & imm_20_21 & S4 & imm_13=1 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
#np
     :"cj40 " is imm_27=0 & imm_22_26=0b01010 & imm_20_21 & S4 & imm_13=0 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj41 " is imm_27=0 & imm_22_26=0b01010 & imm_20_21 & S4 & imm_13=1 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj42 " is imm_27=0 & imm_22_26=0b01011 & imm_20_21 & S4 & imm_13=0 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj43 " is imm_27=0 & imm_22_26=0b01011 & imm_20_21 & S4 & imm_13=1 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj44 " is imm_27=0 & imm_22_26=0b01100 & imm_20_21 & S4 & imm_13=0 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj45 " is imm_27=0 & imm_22_26=0b01100 & imm_20_21 & S4 & imm_13=1 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj46 " is imm_27=0 & imm_22_26=0b01101 & imm_20_21 & S4 & imm_13=0 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
     :"cj47 " is imm_27=0 & imm_22_26=0b01101 & imm_20_21 & S4 & imm_13=1 & imm_8_12 & imm_1_7 & imm_0=0 {
	     _stub();
     }
# second chunk

     #..
     slot:"p0=cmp.eq("S4", "imm_8_12"); if (p0.new) jump:nt "r9 is imm_22_27=0b000000 & imm_20_21 & S4 & imm_13=0 & imm_8_12 & imm_1_7 & imm_0=0 [ r9 = imm_1_7 | (imm_20_21 << 7);] {
        
     _stub();
     }
     #..
 }


# J/Jump to address
with slot: iclass=0b0101 {

    JImm: loc is imm_16_24 & imm_1_13 [loc = inst_start+(((imm_16_24 << 13) | (imm_1_13)) << 2);]{
        export *[ram]:4 loc;
    }

    slot:"J" JImm  is imm_25_27=0b100  &  imm_0=0 & JImm  {
        goto JImm;
     }
    
    IfImm: r15 is imm_1_7 & imm_13 & imm_16_20 [r15 = inst_start + ((imm_1_7 | (imm_13 << 7) | (imm_16_20 << 8)) << 2);] {
        export *[ram]:4 r15;
    }

	 slot:"if ("U2") jump:nt #"IfImm is  imm_24_27=0b1100 & imm_22_23 & imm_21=0 & imm_11_12=0b00 & imm_10=0 & U2 & imm_0=0 & IfImm  {
         if(U2 != 0) goto IfImm;
	 }

	 slot:"if ("U2") jump:t num" is  imm_24_27=0b1100 & imm_22_23 & imm_21=0 & imm_16_20 & imm_13 & imm_11_12=0b10 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
     
	 slot:"if (!"U2") jump:nt num" is  imm_24_27=0b1100 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_11_12=0b00 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }

	 slot:"if (!"U2") jump:t num" is  imm_24_27=0b1100 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_11_12=0b10 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
 }

# J/Jump to address cond new
with slot: iclass=0b0101 {
	 slot:"if ("U2".new) jump:nt num" is imm_24_27=0b1100 & imm_22_23 & imm_21=0 & imm_16_20 & imm_13 & imm_11_12=0b01 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
	 slot:"if ("U2".new) jump:t num" is imm_24_27=0b1100 & imm_22_23 & imm_21=0 & imm_16_20 & imm_13 & imm_11_12=0b11 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
	 slot:"if (!"U2".new) jump:nt num" is imm_24_27=0b1100 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_11_12=0b01 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
	 slot:"if (!"U2".new) jump:t num" is imm_24_27=0b1100 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_11_12=0b11 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
}
# J/Jump to address cond reg

# J/Transfer and jump
with slot: iclass=0b0001 {
	 slot:D4_16_19"=num; jump num" is imm_24_27=0b0110 & imm_22_23=0 & imm_20_21 & D4_16_19 & imm_8_13 & imm_1_7 & imm_0=0 {
     _stub();
	 }
	 slot:D4_8_11"="S4"; jump num" is imm_24_27=0b0111 & imm_22_23=0 & imm_20_21 & S4 & imm_12_13=0 & D4_8_11 & imm_1_7 & imm_0=0 {
     _stub();
	 }
}


# LD
    # Special case for constant extender
    wslot:"D5=memw__EXT(S5+#s11)" is iclass64=0b110 & imm64_27=0 & imm64_25_26 & imm64_21_24=0b1100 & S564 & imm64_5_13 & D564 {
    _stub();
    }

#LD:Load word
with slot: iclass=0b1001 {
    :D5"=memw("S5"+#"s11")" is imm_27=0 & imm_25_26 & imm_21_24=0b1100 & S5 & imm_5_13 & D5 [s11 = (imm_5_13 | (imm_25_26 << 9))<<2;] {
        local tmp:2 = s11 << 3;
        local tmp1:2 = tmp s>> 3;
        local EA:4 = S5 + sext(tmp1);
        D5 = *[ram]:4 EA;
    }
}

#LD:Load word cond
with slot: iclass=0b0011 {
    slot:"lwcond0()" is imm_21_27=0b0000100 & S5 & imm_13 & T5 & imm_7 & imm_5_6 & D5  {
        _stub();
    }
    slot:"lwcond1()" is imm_21_27=0b0001100 & S5 & imm_13 & T5 & imm_7 & imm_5_6 & D5  {
        _stub();
    }
    slot:"lwcond3()" is imm_21_27=0b0010100 & S5 & imm_13 & T5 & imm_7 & imm_5_6 & D5  {
        _stub();
    }
    slot:"lwcond4()" is imm_21_27=0b0011100 & S5 & imm_13 & T5 & imm_7 & imm_5_6 & D5  {
        _stub();
    }
}
with slot: iclass=0b0100 {
    slot:"lwcond5()" is imm_21_27=0b0001100 & S5 & imm_13=0 & imm_11_12 & imm_5_10 & D5  {
        _stub();
    }
    slot:"lwcond6()" is imm_21_27=0b0011100 & S5 & imm_13=0 & imm_11_12 & imm_5_10 & D5  {
        _stub();
    }
    slot:"lwcond7()" is imm_21_27=0b0101100 & S5 & imm_13=0 & imm_11_12 & imm_5_10 & D5  {
        _stub();
    }
    slot:"lwcond8()" is imm_21_27=0b0111100 & S5 & imm_13=0 & imm_11_12 & imm_5_10 & D5  {
        _stub();
    }
}
with slot: iclass=0b1001 {
    slot:"lwcond9()" is imm_21_27=0b1011100 & S5 & imm_11_13=0b100 & imm_9_10 & imm_5_8 & D5  {
        _stub();
    }
    slot:"lwcond10()" is imm_21_27=0b1011100 & S5 & imm_11_13=0b101 & imm_9_10 & imm_5_8 & D5  {
        _stub();
    }
    slot:"lwcond11()" is imm_21_27=0b1011100 & S5 & imm_11_13=0b110 & imm_9_10 & imm_5_8 & D5  {
        _stub();
    }
    slot:"lwcond11()" is imm_21_27=0b1011100 & S5 & imm_11_13=0b111 & imm_9_10 & imm_5_8 & D5  {
        _stub();
    }

    slot:"lwcond12()" is imm_21_27=0b1111100 & imm_16_20 & imm_11_13=0b100 & imm_9_10 & imm_8 & imm_7=1 & imm_5_6=0 & D5  {
        _stub();
    }
    slot:"lwcond13()" is imm_21_27=0b1111100 & imm_16_20 & imm_11_13=0b101 & imm_9_10 & imm_8 & imm_7=1 & imm_5_6=0 & D5  {
        _stub();
    }
    slot:"lwcond14()" is imm_21_27=0b1111100 & imm_16_20 & imm_11_13=0b110 & imm_9_10 & imm_8 & imm_7=1 & imm_5_6=0 & D5  {
        _stub();
    }
    slot:"lwcond15()" is imm_21_27=0b1111100 & imm_16_20 & imm_11_13=0b111 & imm_9_10 & imm_8 & imm_7=1 & imm_5_6=0 & D5  {
        _stub();
    }
}

#LD:Dealloc
with slot: iclass=0b1001 {
    slot:"deallocframe()" is imm_21_27=0b0000000 & S5 & imm_13=0 & imm_5_12=0 & D5  {
        _stub();
    }
}

#LD:Dealloc return
with slot: iclass=0b1001 {
    slot:D5"=dealloc_return("S5"):raw" is imm_21_27=0b0110000 & S5 & imm_10_13=0 & imm_5_9=0 & D5  {
        local EA:4 = S5;
        local tmp:8 = *[ram]:4 EA;
        D5 = tmp:4;
        local tmp2:8 = tmp>>32;
        local tmp3:4 = tmp2:4;
        SP = EA+8;
        return [tmp3];
    }
}

# MEMOP/hw
with slot: iclass=0b0011 {
    :"memopb0" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }
    :"memopb1" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }
    :"memopb2" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }
    :"memopb3" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }


    :"memopb4" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }
    :"memopb5" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }
    :"memopb6" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }
    :"memopb7" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }
}

# MEMOP/byte
with slot: iclass=0b0011 {
    :"memopb0" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }
    :"memopb1" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }
    :"memopb2" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }
    :"memopb3" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }


    :"memopb4" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }
    :"memopb5" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }
    :"memopb6" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }
    :"memopb7" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b00 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }
}

# MEMOP/word
with slot: iclass=0b0011 {
    slot:"memw()+=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }

    slot:"memw()-=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }

    slot:"memw()&=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }

    slot:"memw()|=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }

    slot:"memw()+=I" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }

    slot:"memw()-=I" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }

    slot:"memw()=clrbit" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }

    slot:"memw()=setbit" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }
}


# ST:Store word
with slot: iclass=0b0011 {
    :"memw("S5"+"T5"<<u2)=T5" is imm_21_27=0b1011100 & S5 & imm_13 & T5 & imm_7 & imm_5_6=0 & imm_0_4 { #  [s11 = (imm_0_7 | (imm_13 << 8) | (imm_16_20 << 9) | (imm_25_26 << 14)) << 2;] {
        #local tmp:2 = s11 << 3;
        #local tmp1:2 = tmp s>> 3;
        #local EA:4 = GP + sext(tmp1);
        #*[ram]:4 EA = T5;
        _stub();
    }
    :"memw("S5"+"U6"=#"S8")" is imm_25_27=0b110 & imm_23_24=0 & imm_21_22=0b10 & S5 & imm_7_12 & imm_0_6 & imm_13 [ U6 = imm_7_12 << 2; S8=imm_0_6 | (imm_13 << 8);] {
        local EA:4 = S5 + U6;
        *[ram]:4 EA = sext(S8:1);

    }
}
with slot: iclass=0b0100 {
    :"memw(gp + "s11")="T5 is imm_27=0 & imm_25_26 & imm_21_24=0b010 & imm_16_20 & imm_13 & T5 & imm_0_7 [s11 = (imm_0_7 | (imm_13 << 8) | (imm_16_20 << 9) | (imm_25_26 << 14)) << 2;] {
        local tmp:2 = s11 << 3;
        local tmp1:2 = tmp s>> 3;
        local EA:4 = GP + sext(tmp1);
        *[ram]:4 EA = T5;
    }
}
with slot: iclass=0b1010 {
    :"memw("S5" + "s11")="T5 is imm_27=0 & imm_25_26 & imm_21_24=0b1100 & S5 & imm_13 & T5 & imm_0_7 [s11 = (imm_0_7 | (imm_13 << 8) | (imm_25_26 << 9)) << 2;] {
        local tmp:2 = s11 << 3;
        local tmp1:2 = tmp s>> 3;
        local EA:4 = S5 + sext(tmp1);
        *[ram]:4 EA = T5;
    }
    :"memw(X5 ++ I:circ(Mu))="T5 is imm_21_27=0b1001100 & S5 & imm_13 & T5 & imm_7=0 & imm_2_6=0 & imm_1=1 & imm_0=0 {
        _stub();
    }
    :"memw(X5 ++ s4:2:circ(Mu))="T5 is imm_21_27=0b1001100 & S5 & imm_13 & T5 & imm_7=0 & imm_2_6=0 & imm_1=0 & imm_0=0 {
        _stub();
    }
    :"memw(Re=U6)="T5 is imm_21_27=0b1011100 & S5 & imm_13=0 & T5 & imm_7=1 & imm_6=0 & imm_0_6  {
        _stub();
    }
    :"memw(Rx++s4:2)="T5 is imm_21_27=0b1011100 & S5 & imm_13=0 & T5 & imm_7=0 & imm_3_6 & imm_2=0 & imm_1=0 & imm_0=0  {
        _stub();
    }
    :"memw(Ru<<u2+u6)="T5 is imm_21_27=0b1101100 & imm_16_20 & imm_13 & T5 & imm_7=1 & imm_6 & imm_0_5  {
        _stub();
    }
    :"memw(Rx++Mu)="T5 is imm_21_27=0b1101100 & S5 & imm_13 & T5 & imm_7=0 & imm_0_6=0 {
        _stub();
    }
    :"memw(Rx++Mu:brev)="T5 is imm_21_27=0b1111100 & S5 & imm_13 & T5 & imm_7=0 & imm_0_6=0 {
        _stub();
    }
}
# ST:Store-release word

# ST:Store word cond
with slot: iclass=0b0011 {
    :"ST0"D5 is imm_21_27=0b0100100 & S5 & imm_13 & imm_8_12 & imm_7 & D5 {
        _stub();
    }
    :"ST1"D5 is imm_21_27=0b0101100 & S5 & imm_13 & imm_8_12 & imm_7 & D5 {
        _stub();
    }
    :"ST2"D5 is imm_21_27=0b0110100 & S5 & imm_13 & imm_8_12 & imm_7 & D5 {
        _stub();
    }
    :"ST3"D5 is imm_21_27=0b0111100 & S5 & imm_13 & imm_8_12 & imm_7 & D5 {
        _stub();
    }

    :"ST4" is imm_21_27=0b1000010 & S5 & imm_13 & imm_7_12 & imm_5_6 & imm_7 & imm_0_4 {
        _stub();
    }
    :"ST5" is imm_21_27=0b1000110 & S5 & imm_13 & imm_7_12 & imm_5_6 & imm_7 & imm_0_4 {
        _stub();
    }
    :"ST6" is imm_21_27=0b1001010 & S5 & imm_13 & imm_7_12 & imm_5_6 & imm_7 & imm_0_4 {
        _stub();
    }
    :"ST7" is imm_21_27=0b1001110 & S5 & imm_13 & imm_7_12 & imm_5_6 & imm_7 & imm_0_4 {
        _stub();
    }
}
with slot: iclass=0b0100 {
    :"ST8" is imm_21_27=0b0000100 & S5 & imm_13 & T5 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"ST9" is imm_21_27=0b0010100 & S5 & imm_13 & T5 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"ST10" is imm_21_27=0b0100100 & S5 & imm_13 & T5 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"ST11" is imm_21_27=0b0110100 & S5 & imm_13 & T5 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
}

with slot: iclass=0b1010 {
    :"ST12" is imm_21_27=0b1011100 & S5 & imm_13=1 & T5 & imm_7=0 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"ST13" is imm_21_27=0b1011100 & S5 & imm_13=1 & T5 & imm_7=0 & imm_3_6 & imm_2=1 & imm_0_1 {
        _stub();
    }
    :"ST14" is imm_21_27=0b1011100 & S5 & imm_13=1 & T5 & imm_7=1 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"ST15" is imm_21_27=0b1011100 & S5 & imm_13=1 & T5 & imm_7=1 & imm_3_6 & imm_2=1 & imm_0_1 {
        _stub();
    }

    :"ST16" is imm_21_27=0b1111100 & imm_18_20 & imm_16_17 & imm_13=0 & T5 & imm_7=1 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"ST17" is imm_21_27=0b1111100 & imm_18_20 & imm_16_17 & imm_13=0 & T5 & imm_7=1 & imm_3_6 & imm_2=1 & imm_0_1 {
        _stub();
    }
    :"ST18" is imm_21_27=0b1111100 & imm_18_20 & imm_16_17 & imm_13=1 & T5 & imm_7=1 & imm_3_6 & imm_2=0 & imm_0_1 {
        _stub();
    }
    :"ST19" is imm_21_27=0b1111100 & imm_18_20 & imm_16_17 & imm_13=1 & T5 & imm_7=1 & imm_3_6 & imm_2=1 & imm_0_1 {
        _stub();
    }
}

# ST:Allocate stack frame
with slot: iclass=0b1010 {

    :"allocframe("S5","U11"):raw" is imm_21_27=0b0000100 & S5 & imm_11_13=0b000 & imm_0_10 [ U11 = imm_0_10 << 3; ] {
        local EA:4 = S5 - 8;
        local lr_8:8 = zext(LR);
        local fp_8:8 = zext(FP);
        *[ram]:8 EA = (lr_8 << 32) | fp_8;
        FP = EA;
        S5 = EA - U11;
    }
}



#SYSTEM/MONITOR:Clr int
define pcodeop ciad;
with slot: iclass=0b0110 {
    slot:"siad("S5")" is imm_21_27=0b0100000 & S5 & imm_8_13=0 & imm_5_7=0b001 & imm_0_4=0 {
        ciad(S5);
    }
}
#SYSTEM/MONITOR:Swp sgp

#SYSTEM/MONITOR:Cancel pend
define pcodeop cswi;
with slot: iclass=0b0110 {
    slot:"cswi("S5")" is imm_21_27=0b0100000 & S5 & imm_8_13=0 & imm_5_7=0b001 & imm_0_4=0 {
        ciad(S5);
    }
}

#SYSTEM/MONITOR:Data cache kil
define pcodeop dckill;
slot:"dckill" is iclass=0b1010 & imm_21_27=0b0010000 & imm_16_20=0 & imm_0_13=0 {
	dckill();
}

#SYSTEM/MONITOR:Data cache mon

#SYSTEM/MONITOR:Read int mask
define pcodeop getimask;
with slot: iclass=0b0110 {
    slot:D5"=getimask("S5")" is imm_21_27=0b0110000 & S5 & imm_5_13=0 & D5 {
        D5=getimask(S5);
    }
}

#SYSTEM/MONITOR:Acq hw lck
define pcodeop tlblock;
define pcodeop k0lock;
with slot: iclass=0b0110 {
    slot:"tlblock" is imm_21_27=0b1100001 & imm_16_20=0 & imm_8_13=0 & imm_5_7=0b001 & imm_0_4=0 {
        tlblock();
    }
    slot:"k0lock" is imm_21_27=0b1100001 & imm_16_20=0 & imm_8_13=0 & imm_5_7=0b011 & imm_0_4=0 {
        k0lock();
    }
}
#SYSTEM/MONITOR:Rel hw lck
define pcodeop tlbunlock;
define pcodeop k0unlock;
with slot: iclass=0b0110 {
    slot:"tlbunlock" is imm_21_27=0b1100001 & imm_16_20=0 & imm_8_13=0 & imm_5_7=0b010 & imm_0_4=0 {
        tlbunlock();
    }
    slot:"k0unlock" is imm_21_27=0b1100001 & imm_16_20=0 & imm_8_13=0 & imm_5_7=0b100 & imm_0_4=0 {
        k0unlock();
    }
}
#SYSTEM/MONITOR:Int thrd assign rd
define pcodeop iassignr;
with slot: iclass=0b0110 {
    slot:D5"=iassignr("S5")" is imm_21_27=0b0110011 & S5 & imm_5_13=0 & D5 {
        D5=iassignr(S5);
    }
}
#SYSTEM/MONITOR:Int thrd assign wr
define pcodeop iassignw;
with slot: iclass=0b0110 {
    slot:D5"=iassignw("S5")" is imm_21_27=0b0100000 & S5 & imm_8_13=0 & imm_5_7=0b010 & imm_0_4=0 {
        D5=iassignw(S5);
    }
}
#SYSTEM/MONITOR:icache maintain super

#SYSTEM/MONITOR:icache maintain op
define pcodeop ickill;
with slot: iclass=0b0101 {
	:"ickill" is imm_21_27=0b0110110 & imm_16_20=0 & imm_11_13=0b010 & imm_0_10=0 {
		ickill();
	}
}
#SYSTEM/MONITOR:l2 cache op by idx
#SYSTEM/MONITOR:l2 cache gbl op
#SYSTEM/MONITOR:l2 cache op by addr
#SYSTEM/MONITOR:l2 tag rw

#SYSTEM/MONITOR:load from phys
with slot: iclass=0b1001 {
	:"memphys" is imm_21_27=0b0010000 & S5 & imm_8_13 & imm_7=0 & imm_5_6=0b00 & D5 {
		_stub();
	}
}

define pcodeop isync;
slot:"isync" is iclass=0b0101 & imm_16_27=0b011111000000 & imm_13=0 & imm_10_12=0 & imm_0_9=0b0000000010 {
	isync();
}


# System / monitor
slot:"trans" is iclass=0b0110 & imm_22_27=0b011100 & imm_21=0 & S5 & imm_7_13=0 & D7 {
	_stub();
}

#SYSTEM/MONITOR:Stop thread
define pcodeop stop;
with slot: iclass=0b0110 {
    slot:"stop("S5")" is imm_21_27=0b0100011 & S5 & imm_8_13=0 & imm_5_7=0b000 & imm_0_4=0 {
        stop(S5);
    }
}

#SYSTEM/MONITOR:SWI

#SYSTEM/MONITOR:TLB

#SYSTEM/MONITOR:Control register trans
with slot: iclass=0b0110 {
    slot:D7_svctrl"="S5 is imm_22_27=0b011100 & imm_21=0 & S5 & imm_7_12=0 & D7_svctrl {
        _stub();
    }
    slot:"Sdd=Rss" is imm_22_27=0b110100 & imm_21=0 & S5 & imm_7_12=0 & D7_svctrl {
        _stub();
    }
    slot:D5"="S7_svctrl is imm_23_27=0b11101 & S7_svctrl & imm_5_13=0 & D5 {
        _stub();
    }
    slot:D5"="S7_svctrl is imm_23_27=0b11110 & S7_svctrl & imm_5_13=0 & D5 {
        _stub();
    }
}
#SYSTEM/MONITOR:Wait mode
define pcodeop wait;
with slot: iclass=0b0110 {
    slot:"wait("S5")" is imm_21_27=0b0100010 & S5 & imm_8_13=0 & imm_5_7=0b000 & imm_0_4=0 {
        wait(S5);
    }
}

#SYSTEM/USER:Load locked
with slot: iclass=0b1001 {
    slot:"wllck" is imm_21_27=0b0010000 & S5 & imm_12_13=0b00 & imm_5_11=0 & D5 {
_stub();
    }
    slot:"rllck" is imm_21_27=0b0010000 & S5 & imm_12_13=0b01 & imm_5_11=0 & D5 {
_stub();
    }
}

#SYSTEM/USER:Store locked
with slot: iclass=0b1010 {
    slot:"wllckst" is imm_21_27=0b0000101 & S5 & imm_13=0 & T5 & imm_2_7=0 & D2 {
_stub();
    }
    slot:"dllckst" is imm_21_27=0b0000111 & S5 & imm_13=0 & T5 & imm_2_7=0 & D2 {
_stub();
    }
}

#SYSTEM/USER:Zero cache line
define pcodeop dcache_zero_addr;
with slot: iclass=0b1010 {
    slot:"dczeroa("S5")" is imm_21_27=0b0000110 & S5 & imm_13=0 & imm_0_12=0 {
dcache_zero_addr(S5);
    }
}

#SYSTEM/USER:barrier
define pcodeop barrier;
with slot: iclass=0b1010 {
    slot:"barrier" is imm_21_27=0b1000000 & imm_16_20=0 & imm_0_13=0 {
barrier();
    }
}

#SYSTEM/USER:Breakpoint
define pcodeop brkpt;
with slot: iclass=0b0110 {
    slot:"brkpt" is imm_21_27=0b1100001 & imm_16_20=0 & imm_8_13=0 & imm_5_7=0b000 & imm_0_4=0 {
        brkpt();
    }
}

#SYSTEM/USER:Data cache prefetch
define pcodeop dcache_fetch;
with slot: iclass=0b0110 {
    slot:"brkpt" is imm_21_27=0b0100000 & S5 & imm_13=0 & imm_11_12=0 & imm_0_10 {
        dcache_fetch(imm_0_10<<3);
    }
}

#SYSTEM/USER:Data cache maintain
define pcodeop dcache_clean_addr;
define pcodeop dcache_cleaninv_addr;
define pcodeop dcache_inv_addr;
with slot: iclass=0b1010 {
    :"dccleana("S5")" is imm_21_27=0b0000000 & S5 & imm_0_13=0  {
        dcache_clean_addr(S5);
    }
    :"dccleaninva("S5")" is imm_21_27=0b0000001 & S5 & imm_0_13=0  {
        dcache_cleaninv_addr(S5);
    }
    :"dcinva("S5")" is imm_21_27=0b0000010 & S5 & imm_0_13=0  {
        dcache_inv_addr(S5);
    }
}

#SYSTEM/USER:Icache maintain
define pcodeop icache_inv_addr;
with slot: iclass=0b1010 {
    :"icinva("S5")" is imm_21_27=0b0110110 & S5 & imm_11_13=0b000 & imm_0_10=0  {
        icache_inv_addr(S5);
    }
}


#SYSTEM/USER:Isync
define pcodeop memory_synch;
with slot: iclass=0b0101 {
    :"isync" is imm_17_27=0b011111000000 & S5 & imm_13=0 & imm_10_12=0 & imm_0_9=0b0000000010  {
        memory_synch(S5);
    }
}

#SYSTEM/USER:L2 fetch todo
define pcodeop l2fetch;
with slot: iclass=0b1010 {
    :"l2fetch0" is imm_21_27=0b0110000 & S5 & imm_13=0 & T5 & imm_0_7=0 {
        l2fetch(S5, T5);
    }
    :"l2fetch1" is imm_21_27=0b0110100 & S5 & imm_13=0 & T5 & imm_0_7=0 {
	_stub();
    }
}


#SYSTEM/USER:pause
define pcodeop pause;
with slot: iclass=0b0101 {
    :"isync" is imm_22_27=0b010001 & imm_16_21=0 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_2_4 & imm_0_1=0  {
        pause();
    }
}

#SYSTEM/USER:mem thread sync
define pcodeop syncht;
with slot: iclass=0b1010 {
    :"isync" is imm_22_27=0b1000010 & imm_16_21=0 & imm_0_13=0 {
        syncht();
    }
}

#SYSTEM/USER:trace
define pcodeop trace;
with slot: iclass=0b0110 {
    :"isync" is imm_21_27=0b0010010 & S5 & imm_0_13=0 {
        trace(S5);
    }
}

#SYSTEM/USER:Trap
define pcodeop trap0;
define pcodeop trap1;
with slot: iclass=0b0101 {
    slot:"trap0" is imm_22_27=0b010000 & imm_16_21=0 & imm_13=0 & imm_8_12 & imm_5_7 & imm_2_4 & imm_0_1 {
        trap0();
    }
    slot:"trap1" is imm_22_27=0b010010 & imm_21=0 & S5 & imm_13=0 & imm_8_12 & imm_5_7 & imm_2_4 & imm_0_1 {
        trap1();
    }
}

# XTYPE - pain starts here
# XTYPE/BIT
with slot: iclass=0b1000 {
    # ..

    # Set/clear/toggle bit
    :D5"=setbit("S5",#"imm_8_12")" is imm_21_27=0b1100110 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b000 & D5 {
       D5 = S5 | (1 << imm_8_12);
    }

    :D5"=clrbit("S5",#"imm_8_12")" is imm_21_27=0b1100110 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b001 & D5 {
       D5 = S5 & ~(1 << imm_8_12);
    }

    # ..
}
# XTYPE/PRED:Pred trans
with slot: iclass=0b1000 {
    :D2_pred"="S5 is imm_21_27=0b0101010 & S5 & imm_2_13=0 & D2_pred {
       D2_pred=S5;
    }
    :D5"="S2_pred is imm_24_27=0b1001 & imm_23=0 & imm_22=1 & imm_18_21=0 & S2_pred & imm_5_13=0 & D5 {
       D5=S2_pred;
    }
}

# XTYPE/SHIFT
with slot: iclass=0b1000 {
# Shift by imm
    :D5"=asr("S5",#"imm_8_12")" is imm_21_27=0b1100000 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b000 & D5 {
        D5 = S5 s>> imm_8_12;
    }

# Shift by imm and acc
# ..
    :alu_X5"+=lsr("S5",#"imm_8_13")" is imm_22_27=0b001000 & imm_21=0 & S5 & imm_8_13 & imm_5_7=0b101 & alu_X5 {
        alu_X5 = alu_X5 + (S5 >> imm_8_13);
        _stub();
        #TODO: chk this, might be a pair
    }

    :alu_X5"+=lsr("S5",#"imm_8_12")" is imm_22_27=0b111000 & imm_21=0 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b101 & alu_X5 {
        alu_X5 = alu_X5 + (S5 >> imm_8_12);
    }
#..


}

# Shift by imm and logical
# ..
slot: "alu_X5=or(#"u8",asl("alu_X5", #"imm_8_12"))" is iclass=0b1101 & imm_24_27=0b1110 & imm_21_23 & alu_X5 & imm_13 & imm_8_12 & imm_5_7 & imm_4=0 & imm_3 & imm_1_2=0b01 & imm_0=0 [ u8 = imm_3 | (imm_5_7 << 1) | (imm_13 << 4) | (imm_21_23 << 5); ] {
    alu_X5 = u8 | (alu_X5 << imm_8_12);
}


# Duplex/L1
L1:"loadri_io" is immdup_13=0 & immdup_9_12 & immdup_5_8 & immdup_0_4 {
_stub();
}
L1:"loadrub_io" is immdup_13=1 & immdup_9_12 & immdup_5_8 & immdup_0_4 {
_stub();
}
:L1L is L1 { build L1; }
:L1R is L1 { build L1; }


duplex:L1L" duplex_0x0 "L1R is imm_29_31=0b000 & L1L ... & imm_13=0 & ...L1R {
}
duplex:"duplex_0x1" is imm_29_31=0b000 & imm_13=1 {
}
duplex:"duplex_0x2" is imm_29_31=0b001 & imm_13=0 {
}
duplex:"duplex_0x3" is imm_29_31=0b001 & imm_13=1 {
}
duplex:"duplex_0x4" is imm_29_31=0b010 & imm_13=0 {
}
duplex:"duplex_0x5" is imm_29_31=0b010 & imm_13=1 {
}
duplex:"duplex_0x6" is imm_29_31=0b011 & imm_13=0 {
}
duplex:"duplex_0x7" is imm_29_31=0b011 & imm_13=1 {
}
duplex:"duplex_0x8" is imm_29_31=0b100 & imm_13=0 {
}
duplex:"duplex_0x9" is imm_29_31=0b100 & imm_13=1 {
}
duplex:"duplex_0xa" is imm_29_31=0b101 & imm_13=0 {
}
duplex:"duplex_0xb" is imm_29_31=0b101 & imm_13=1 {
}
duplex:"duplex_0xc" is imm_29_31=0b110 & imm_13=0 {
}
duplex:"duplex_0xd" is imm_29_31=0b110 & imm_13=1 {
}
duplex:"duplex_0xe" is imm_29_31=0b111 & imm_13=0 {
}
duplex:"duplex_0xf" is imm_29_31=0b111 & imm_13=1 {
}


# special contant extender handling
#slot:"Cext" is iclass=0b0000 {
#_stub();
#}

slot0: slot is slot &  (parse=0b01 | parse=0b10) & iclass!=0b0000{ build slot; }
slot1: slot0 is slot0 { build slot0; }
slot2: slot0 is slot0 { build slot0; }
slotX: slot is slot & parse=0b11  { build slot; }
slotX: duplex is duplex & parse=0b00  { build duplex; }

:{ slot0 slotX } is slot0;slotX {
	build slot0;
	build slotX;
}
:{ slot0 slot1 slotX } is slot0;slot1;slotX {
	build slot0;
	build slot1;
	build slotX;
}
:{ slot0 slot1 slot2 slotX } is slot0;slot1;slot2;slotX {
	build slot0;
	build slot1;
	build slot2;
	build slotX;
}

:{ slotX } is slotX {
	build slotX;
} 

wslot0:wslot is wslot & iclassw=0b0000 & (parsew=0b01 | parsew=0b10) & (parse64=0b10 | parse64=0b01) { build wslot; }
wslotX: wslot is wslot & iclassw=0b0000 & (parsew=0b01 | parsew=0b10) & parse64=0b11 { build wslot; }

:{ wslotX } is wslotX {
	build wslotX;
} 

:{ wslot0 wslotX } is wslot0; wslotX {
	build wslot0;
	build wslotX;
} 

:{ wslot0 slot0 slotX } is wslot0; slot0; slotX {
	build wslot0;
	build slot0;
	build slotX;
} 

:{ wslot0 slotX } is wslot0; slotX {
	build wslot0;
	build slotX;
} 

#:{ wslot0 } is wslot0 {
#	build wslot0;
#} 

#wslotX: wslot is wslot & (parse_0=0b01 | parse_0=0b10) & parse_1=0b11 { build wslot; }
#:{ wslotX } is wslotX {
#	build wslotX;
#} 

#define register offset=0x00 size=1 [ Rd ];

#define register offset=0x00 size=2 [ AF  BC  DE  HL ];
#define register offset=0x20 size=1 [ A_ F_ B_ C_ D_ E_ H_ L_ ]; # Alternate registers
#define register offset=0x20 size=2 [ AF_   BC_   DE_   HL_ ]; # Alternate registers

#define register offset=0x40 size=2 [ _  PC SP IX IY ];

#define register offset=0x50 size=1 [ rCBAR rCBR rBBR ];

# Define context bits (if defined, size must be multiple of 4-bytes)
#define register offset=0xf0 size=4   contextreg;

#define context contextreg
  #assume8bitIOSpace		= (0,0)
#;

# Flag bits (?? manual is very confusing - could be typos!)
#@define C_flag "F[0,1]"		# C: Carry
#@define N_flag "F[1,1]"		# N: Add/Subtract
#@define PV_flag "F[2,1]"	# PV: Parity/Overflow
#@define H_flag "F[4,1]"		# H: Half Carry
#@define Z_flag "F[6,1]"		# Z: Zero
#@define S_flag "F[7,1]"		# S: Sign

# Include contents of skel.sinc file
#@include "skel.sinc"
