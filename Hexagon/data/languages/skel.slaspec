# sleigh specification file for Skeleton Processor
#   >> see docs/languages/sleigh.htm or sleigh.pdf for Sleigh syntax
# Other language modules (see Ghidra/Processors) may provide better examples
# when creating a new language module.


# List of nice-to-haves in SELIGH
# arbitary bit-count sext, not just bytes
# allow sext and s>> in [] bit of constructor

define endian=little;
define alignment=4;

define space ram     type=ram_space      size=4 wordsize=1 default;
define space register type=register_space size=4;

define token instr (32)
   iclass     = (28,31)

   imm_29_31 = (29, 31)

   imm_27 = (27, 27)

   imm_25_27 = (25, 27)
   imm_25_26 = (25, 26) signed

   imm_24_27 = (24, 27)

   imm_23_24 = (23, 24)
   imm_23 = (23, 23)

   imm_22_27 = (22, 27)
   imm_22_23 = (22, 23)

   imm_21_27 = (21, 27) signed
   imm_21_24 = (21, 24)
   imm_21_23 = (21, 23)
   imm_21_22 = (21, 22)
   imm_21 = (21, 21)

   imm_20_27 = (20, 27)

   imm_18_19 = (18, 19)

   imm_16_27 = (16, 27)
   imm_16_25 = (16, 25)
   imm_16_24 = (16, 24)
   imm_16_23 = (16, 23)
   imm_16_20 = (16, 20)

   imm_13 = (13, 13) signed
   imm_12 = (12, 12)

   imm_11_13 = (11, 13)
   imm_11_12 = (11, 12)
   imm_11 = (11, 11)

   imm_10_13 = (10, 13)
   imm_10_12 = (10, 12)
   imm_10 = (10, 10)

   imm_8_13 = (8, 13)
   imm_8_12 = (8, 12)

   imm_7_13 = (7, 13)
   imm_7_12 = (7, 12)
   imm_7 = (7, 7)

   imm_6_13 = (6, 13)

   imm_5_13 = (5, 13) signed
   imm_5_12 = (5, 12)
   imm_5_9 = (5, 9)
   imm_5_7 = (5, 7)
   imm_5_6 = (5, 6)

   imm_4 = (4, 4)

   imm_3_12 = (3, 12)
   imm_3_4 = (3, 4)
   imm_3 = (3, 3)

   imm_2_12 = (2, 12)
   imm_2_7 = (2, 7)
   imm_2_5 = (2, 5)
   imm_2_4 = (2, 4)
   imm_2_3 = (2, 3)
   imm_2 = (2, 2)

   imm_1_13 = (1, 13)
   imm_1_7 = (1, 7)
   imm_1_2 = (1, 2)

   imm_0_13 = (0, 13)
   imm_0_10 = (0, 10)
   imm_0_9 = (0, 9)
   imm_0_7 = (0, 7) signed
   imm_0_6 = (0, 6)
   imm_0_2 = (0, 2)
   imm_0_1 = (0, 1)
   imm_0 = (0, 0)
   

   S2 = (16,17)
   T2 = (8,9)
   D2 = (0,1)

   S2_pred = (16,17)
   T2_pred = (8,9)
   D2_pred = (0,1)
   U2_pred = (8,9)

   T5 = (8,12)
   
   
   Rs = (27, 27)
   MajOp = (24,26)
   MinOp = (21,23)
   D7 = (0,7)
   D5 = (0,4)
   D5_ctrl = (0,4)
   S5 = (16,20)
   S5_ctrl = (16,20)
   alu_X5 = (16,20)
   U2 = (8,9)
   
   parse = (14, 15)
  	imm32 = (0, 31)
;

define register offset=0x00 size=4 [ 
X0 
X1 
X2 
X3 
X4 
X5 
X6 
X7 
X8 
X9 
X10 
X11 
X12 
X13 
X14 
X15 
X16 
X17 
X18 
X19 
X20 
X21 
X22 
X23 
X24 
X25 
X26 
X27 
X28 
SP
FP
LR
 ];

attach variables [ D5 S5 alu_X5 ] [
X0 
X1 
X2 
X3 
X4 
X5 
X6 
X7 
X8 
X9 
X10 
X11 
X12 
X13 
X14 
X15 
X16 
X17 
X18 
X19 
X20 
X21 
X22 
X23 
X24 
X25 
X26 
X27 
X28 
SP
FP
LR
];


 define register offset=0x80 size=4 [ 
SA0
LC0
SA1
LC1
P30
Reserve_5
M0
M1
USR
PC
UGP
GP
CS0
CS1
UPCYCLELO
UPCYCLEHI

Reserved_16
Reserved_17
Reserved_18
Reserved_19
Reserved_20
Reserved_21
Reserved_22
Reserved_23
Reserved_24
Reserved_25
Reserved_26
Reserved_27
Reserved_28
Reserved_29
Reserved_30
Reserved_31
 ];

 
 attach variables [ D5_ctrl S5_ctrl ] [
 SA0
LC0
SA1
LC1
P30
Reserve_5
M0
M1
USR
PC
UGP
GP
CS0
CS1
UPCYCLELO
UPCYCLEHI

Reserved_16
Reserved_17
Reserved_18
Reserved_19
Reserved_20
Reserved_21
Reserved_22
Reserved_23
Reserved_24
Reserved_25
Reserved_26
Reserved_27
Reserved_28
Reserved_29
Reserved_30
Reserved_31
];

define register offset=0x100 size=4 [ 
P0
P1
P2
P3
];
attach variables [ U2 D2_pred T2_pred S2_pred U2_pred ] [
P0
P1
P2
P3
];


Addr32i:  is    imm_16_24 & imm_1_13 {


	local loc:4 = (((imm_16_24 << 13) | (imm_1_13)) << 2);
	local loc1:3 = loc:3;
	local loc2:4 = sext(loc1);

	local loc3:4 = loc2 + inst_start;
 export *:4 loc3;
  }



 define pcodeop _stub;

 
# ALU32/ALU:add
slot:D5" = add("S5",#"loc")" is iclass=0b1011 & S5 & D5 & imm_21_27 & imm_5_13 [loc= ((imm_21_27 << 9) | (imm_5_13));] {
    D5 = S5 + sext(loc:2);
} 
slot:D5" = add("S5","T5")" is iclass=0b1111 & S5 & D5 & imm_21_27=0b0011000 & S5 & imm_13=0 & T5 & imm_5_7=0 {
    D5 = S5 + T5;
} 
slot:D5" = add("S5","T5"):sat" is iclass=0b1111 & S5 & D5 & imm_21_27=0b0011001 & S5 & imm_13=0 & T5 & imm_5_7=0 {
    #D5 = S5 + T5;
    _stub();
} 

# ALU32/ALU:logical
with slot: iclass=0b0111 {
	:D5 = "and"(S5,#s10) is Rs=0 & MajOp = 0b110 & imm_22_23=0b00 & imm_21 & S5 & imm_5_13 & D5 [ s10 = (imm_21 << 9) | imm_5_13;] {
		D5 = S5 & s10;
	} 

	:D5 = "or"(S5,#s10) is Rs=0 & MajOp = 0b110 & imm_22_23=0b10 & imm_21 & S5 & imm_5_13 & D5 [ s10 = (imm_21 << 9) | imm_5_13;] {
		D5 = S5 & s10;
	} 
}
with slot: iclass=0b1111 {
	:D5 = "and("S5","T5")" is imm_21_27=0b0001000 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = S5 & T5;
	} 

	:D5 = "or("S5","T5")" is imm_21_27=0b0001001 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = S5 | T5;
	} 

	:D5 = "xor("S5","T5")" is imm_21_27=0b0001011 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = S5 ^ T5;
	} 

	:D5 = "and("T5",~"S5")" is imm_21_27=0b0001100 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = T5 & (~S5);
	} 

	:D5 = "or("T5",~"S5")" is imm_21_27=0b0001101 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		D5 = T5 | (~S5);
	} 
}
# ALU32/ALU:negate
# TODO

# ALU32/ALU:nop
with slot: iclass=0b0111 {
	:"nop" is imm_24_27=0b1111 & imm_16_23  & imm_0_13 {}
}

# ALU32/ALU:subtract
with slot: iclass=0b0111 {
	slot:" = sub()" is imm_22_27=0b011001 & imm_21 & S5 & imm_5_13 & D5 {
		_stub();
	} 
}
with slot: iclass=0b1111 {
	slot:D5" = sub("T5","S5")" is imm_21_27=0b0011001 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
	    D5 = T5 - S5;
	} 

	slot:D5" = sub("T5","S5"):sat" is imm_21_27=0b0110110 & S5 & imm_13=0 & T5 & imm_5_7=0 & D5 {
		_stub();
	    #D5 = T5 - S5;
	} 
}


# ALU32/ALU:sext
with slot: iclass=0b0111 {
	slot:D5" = sxtb("S5")" is imm_21_27=0b0000101 & S5 & imm_13=0 & imm_5_12=0 & D5 {
	_stub();
	} 
	slot:D5" = sxth("S5")" is imm_21_27=0b0000111 & S5 & imm_13=0 & imm_5_12=0 & D5 {
	_stub();
	} 
}

# ALU32/ALU:trans_imm
 with slot: iclass=0b0111 {
  	
	ImmU16: v is    imm_22_23 & imm_0_13  [ v = (imm_22_23 << 13) | (imm_0_13); ] {
		local v1:4 = v;
	 	export v1;
	  }
	  
  	TI_S16: v is    imm_22_23 & imm_16_20 & imm_5_13  [ v = (imm_5_13) | (imm_16_20 << 9) | (imm_22_23 << 14); ] {
		local v1:4 = v;
	 	export v1;
	  }
	  
 
	:alu_X5^".L" = ImmU16 is Rs = 0 & MajOp = 0b001 & imm_21=1 & alu_X5 & ImmU16 {
		local tmp:4 = alu_X5 & 0xFFFF0000;
		alu_X5 = tmp | ImmU16;
	}
	
	:alu_X5^".H" = ImmU16 is Rs = 0 & MajOp = 0b010 & imm_21=1 & alu_X5 & ImmU16 {
		local tmp:4 = alu_X5 & 0x0000FFFF;
		alu_X5 = tmp | (ImmU16 << 16);
	}
	
	:D5=TI_S16 is  Rs = 1 & MajOp=0b000 & imm_21=0 & TI_S16 & D5 {
		D5 = TI_S16;
	}  
}


# ALU32/ALU:trans_reg
 with slot: iclass=0b0111 {

    # Transfer register
	:D5"="S5 is Rs = 0 & MajOp = 0b000 & MinOp=0b011 & S5 & imm_13=0 & imm_5_12=0 & D5 {
        D5 = S5;
	}
}


# ALU32/ALU:vechw
# ALU32/ALU:vecahw
# ALU32/ALU:vecshw

# ALU32/ALU:zext
 with slot: iclass=0b0111 {
	:D5"="S5 is imm_21_27=0b0000110 & S5 & imm_13=0 & imm_5_12=0 & D5 {
	_stub();
	}
}



# ALU32/PRED
 with slot: iclass=0b0111 {
    # Compare
	:D2="cmp.eq"(S5, "num") is Rs = 0 & MajOp=0b101 & imm_22_23=0b00 & imm_21 & S5 & imm_5_13 & imm_2_4=0b000 & D2 {
	}  

}


 # JR / J
 with slot: iclass=0b0101 {
    # JR

    # call from reg
	 slot:"callr" S5 is imm_21_27=0b0000101 & S5 & imm_0_13=0b00000000000000 {
         _stub();
	 }

	 slot:"if ("U2") callr" S5 is imm_21_27=0b0001000 & S5 & imm_10_13=0 & U2 & imm_0_7=0 {
         _stub();
	 }
	 slot:"if (!"U2") callr" S5 is imm_21_27=0b0001001 & S5 & imm_10_13=0 & U2 & imm_0_7=0 {
         _stub();
	 }


    # Jump to addr from reg
	 slot:"jumpr" S5 is imm_21_27=0b0010100 & S5 & imm_0_13=0b00000000000000 {
		goto [S5];
	 }
 }


     # J

 with slot: iclass=0b0101 {
     # Call subroutine
    Call_R22: is imm_16_25 & imm_1_13 {
        local loc:4 = (((imm_16_25 << 13) | (imm_1_13)) << 2);
        local loc1:3 = loc:3;
        local loc2:4 = sext(loc1);

        local loc3:4 = loc2 + inst_start;
        export *:4 loc3;
      }
	 slot:"call" Call_R22 is imm_25_27=0b101 & Call_R22 & imm_0=0 {
        LR = inst_next;
        call Call_R22;
	 }

	 slot:"if ("U2") call num" is imm_24_27=0b1101 & imm_22_23 & imm_21=0 & imm_16_20 & imm_13 & imm_12=0 & imm_11=0 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }

	 slot:"if (!"U2") call num" is imm_24_27=0b1101 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_12=0 & imm_11=0 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }


     # Jump to address

    slot:"J" Addr32i  is imm_25_27=0b100  &  imm_0_1 & Addr32i {
        goto Addr32i;
     }

	 slot:"if ("U2") jump:nt num" is  imm_24_27=0b1100 & imm_22_23 & imm_21=0 & imm_16_20 & imm_13 & imm_11_12=0b00 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }

	 slot:"if ("U2") jump:t num" is  imm_24_27=0b1100 & imm_22_23 & imm_21=0 & imm_16_20 & imm_13 & imm_11_12=0b10 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }
     
	 slot:"if (!"U2") jump:nt num" is  imm_24_27=0b1100 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_11_12=0b00 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }

	 slot:"if (!"U2") jump:t num" is  imm_24_27=0b1100 & imm_22_23 & imm_21=1 & imm_16_20 & imm_13 & imm_11_12=0b10 & imm_10=0 & U2 & imm_1_7 & imm_0=0 {
     _stub();
	 }



#d
    
 }

# Compare and jump
#with slot: iclass=0b0001 {
#}


# CR
with slot: iclass=0b0110 {
    #endloop - no encoding?

    # Corner detection
    slot:"fastcorner9" is imm_20_27=0b10110000 & imm_18_19=0b00 & S2 & imm_13=1 & imm_10_12=0b000 & T2 & imm_7=1 & imm_5_6=0b00 & imm_4=1 & imm_2_3=0b00 & D2 {
        _stub();
    }
    slot:"!fastcorner9" is imm_20_27=0b10110001 & imm_18_19=0b00 & S2 & imm_13=1 & imm_10_12=0b000 & T2 & imm_7=1 & imm_5_6=0b00 & imm_4=1 & imm_2_3=0b00 & D2 {
        _stub();
    }

    # Logical reduction
    slot:"all8" is imm_20_27=0b10111000 & imm_18_19=0b00 & S2 & imm_13=0 & imm_2_12=0 & D2 {
        _stub();
    }
    slot:"any8" is imm_20_27=0b10111010 & imm_18_19=0b00 & S2 & imm_13=0 & imm_2_12=0 & D2 {
        _stub();
    }

    # Loops
    slot:"loop0" is imm_21_27=0b0000000 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2=0 {
        _stub();
    }
    slot:"loop1" is imm_21_27=0b0000001 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2=0 {
        _stub();
    }
    slot:"loop0_" is imm_21_27=0b1001000 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0 & imm_3_4 & imm_0_2=0 {
        _stub();
    }
    slot:"loop1_" is imm_21_27=0b1001001 & S5 & imm_13=0 & imm_3_12 & imm_2=0 & imm_0_1  {
        _stub();
    }

    # Pc add
    slot:"pcadd" is imm_16_27=0b101001001001 & imm_13=0 & imm_7_12 & imm_5_6=0 & D5 {
        _stub();
    }

    # Pipelined loop TODO

    # Logical predicates TODO
    slot:D2_pred"=and("T2_pred", "S2_pred")" is imm_20_27=0b10110000 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred & S2_pred;
    }

    slot:D2_pred"=and("S2_pred", and("T2_pred","U2_pred"))" is imm_20_27=0b10110001 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & T2_pred & U2_pred;
    }

    slot:D2_pred"=or("T2_pred", "S2_pred")" is imm_20_27=0b10110010 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred | S2_pred;
    }

    slot:D2_pred"=and("S2_pred", or("T2_pred","U2_pred"))" is imm_20_27=0b10110011 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred | U2_pred);
    }

    slot:D2_pred"=xor("T2_pred", "S2_pred")" is imm_20_27=0b10110100 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred ^ S2_pred;
    }

    slot:D2_pred"=or("S2_pred", and("T2_pred","U2_pred"))" is imm_20_27=0b10110101 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred | U2_pred);
    }

    slot:D2_pred"=and("T2_pred", !"S2_pred")" is imm_20_27=0b10110110 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred & ~S2_pred;
    }

    slot:D2_pred"=or("S2_pred", or("T2_pred","U2_pred"))" is imm_20_27=0b10110111 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred | (T2_pred | U2_pred);
    }

    slot:D2_pred"=and("S2_pred", and("T2_pred", !"U2_pred"))" is imm_20_27=0b10111001 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred & ~U2_pred);
    }

    slot:D2_pred"=and("S2_pred", or("T2_pred", !"U2_pred"))" is imm_20_27=0b10111011 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred & (T2_pred | ~U2_pred);
    }

    slot:D2_pred"=not("S2_pred")" is imm_20_27=0b10111100 & imm_18_19=0 & S2_pred & imm_13=0 & imm_2_12=0 & D2_pred {
        D2_pred = ~S2_pred;
    }

    slot:D2_pred"=or("S2_pred", and("T2_pred", !"U2_pred"))" is imm_20_27=0b10111101 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred | (T2_pred & ~U2_pred);
    }

    slot:D2_pred"=or("T2_pred", !"S2_pred")" is imm_20_27=0b10111110 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & imm_2_7=0 & D2_pred {
        D2_pred = T2_pred | ~S2_pred;
    }

    slot:D2_pred"=or("S2_pred", or("T2_pred", !"U2_pred"))" is imm_20_27=0b10111111 & imm_18_19=0 & S2_pred & imm_13=0 & imm_10_12=0 & T2_pred & U2_pred & imm_2_5=0 & D2_pred {
        D2_pred = S2_pred | (T2_pred | ~U2_pred);
    }

    # User control register transfer
#    slot: D5_ctrl = S5 is imm_21_27=0b0010001 & S5_ctrl & imm_5_13=0 & D5 {
#        D5_ctrl = S5;
#    }
#    slot: "D5_ctrl = S5 (dd/ss)" is imm_21_27=0b0011001 & S5_ctrl & imm_5_13=0 & D5 {
#        #D5 = S5_ctrl;
#    }
#    slot: "D5 = S5_ctrl (dd/ss)" is imm_21_27=0b1000000 & S5_ctrl & imm_5_13=0 & D5 {
#        #D5 = S5_ctrl;
#    }
    slot: D5 = S5_ctrl is imm_21_27=0b1010000 & S5_ctrl & imm_5_13=0 & D5 {
        D5 = S5_ctrl;
    }
}

# LD
with slot: iclass=0b1001 {
    # Load word
    slot:D5"=memw("S5"+#"s11")" is imm_27=0 & imm_25_26 & imm_21_24=0b1100 & S5 & imm_5_13 & D5 [s11 = (imm_5_13 | (imm_25_26 << 9))<<2;] {
        local tmp:2 = s11 << 3;
        local tmp1:2 = tmp s>> 3;
        local EA:4 = S5 + sext(tmp1);
        D5 = *[ram]:4 EA;
    }

    slot:"deallocframe()" is imm_21_27=0b0000000 & S5 & imm_13=0 & imm_5_12=0 & D5  {
        _stub();
    }

    slot:D5"=dealloc_return("S5"):raw" is imm_21_27=0b0110000 & S5 & imm_10_13=0 & imm_5_9=0 & D5  {
        local EA:4 = S5;
        local tmp:8 = *[ram]:4 EA;
        D5 = tmp:4;
        local tmp2:8 = tmp>>32;
        local tmp3:4 = tmp2:4;
        SP = EA+8;
        return [tmp3];
    }
}


# MEMOP
with slot: iclass=0b0011 {
    # On memory word

    slot:"memw()+=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }

    slot:"memw()-=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }

    slot:"memw()&=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }

    slot:"memw()|=R" is imm_24_27=0b1110 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }

    slot:"memw()+=I" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b00 & T5 {
    _stub();
    }

    slot:"memw()-=I" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b01 & T5 {
    _stub();
    }

    slot:"memw()=clrbit" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b10 & T5 {
    _stub();
    }

    slot:"memw()=setbit" is imm_24_27=0b1111 & imm_23=0 & imm_21_22=0b01 & S5 & imm_13=0 & imm_7_12 & imm_5_6=0b11 & T5 {
    _stub();
    }
}


# ST
with slot: iclass=0b1010 {
    # Store word

    slot:"memw("S5" + "s11")="T5 is imm_27=0 & imm_25_26 & imm_21_24=0b1100 & S5 & imm_13 & T5 & imm_0_7 [s11 = (imm_0_7 | (imm_13 << 8) | (imm_25_26 << 9)) << 2;] {
        local tmp:2 = s11 << 3;
        local tmp1:2 = tmp s>> 3;
        local EA:4 = S5 + sext(tmp1);
        *[ram]:4 EA = T5;
    }


    slot:"allocframe("S5","U11"):raw" is imm_21_27=0b0000100 & S5 & imm_11_13=0b000 & imm_0_10 [ U11 = imm_0_10 << 3; ] {
        local EA:4 = S5 - 8;
        local lr_8:8 = zext(LR);
        local fp_8:8 = zext(FP);
        *[ram]:8 EA = (lr_8 << 32) | fp_8;
        FP = EA;
        S5 = EA - U11;
    }
}
with slot: iclass=0b0011 {


    slot:"memw("S5"+"U6"=#"S8")" is imm_25_27=0b110 & imm_23_24=0 & imm_21_22=0b10 & S5 & imm_7_12 & imm_0_6 & imm_13 [ U6 = imm_7_12 << 2; S8=imm_0_6 | (imm_13 << 8);] {
        local EA:4 = S5 + U6;
        *[ram]:4 EA = sext(S8:1);

    }
}



# system

define pcodeop isync;
define pcodeop dckill;
define pcodeop ickill;

slot:"isync" is iclass=0b0101 & imm_16_27=0b011111000000 & imm_13=0 & imm_10_12=0 & imm_0_9=0b0000000010 {
	isync();
}


# System / monitor
slot:"trans" is iclass=0b0110 & imm_22_27=0b011100 & imm_21=0 & S5 & imm_7_13=0 & D7 {
	_stub();
}
slot:"dckill" is iclass=0b1010 & imm_21_27=0b0010000 & imm_16_20=0 & imm_0_13=0 {
	dckill();
}
slot:"ickill" is iclass=0b0101 & imm_21_27=0b0110110 & imm_16_20=0 & imm_11_13=0b010 & imm_0_10=0 {
	ickill();
}


# XTYPE - pain starts here
# XTYPE/BIT
with slot: iclass=0b1000 {
    # ..

    # Set/clear/toggle bit
    :D5"=setbit("S5",#"imm_8_12")" is imm_21_27=0b1100110 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b000 & D5 {
       D5 = S5 | (1 << imm_8_12);
    }

    :D5"=clrbit("S5",#"imm_8_12")" is imm_21_27=0b1100110 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b001 & D5 {
       D5 = S5 & ~(1 << imm_8_12);
    }

    # ..
}

# XTYPE/SHIFT
with slot: iclass=0b1000 {
# Shift by imm
    :D5"=asr("S5",#"imm_8_12")" is imm_21_27=0b1100000 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b000 & D5 {
        D5 = S5 s>> imm_8_12;
    }

# Shift by imm and acc
# ..
    :alu_X5"+=lsr("S5",#"imm_8_13")" is imm_22_27=0b001000 & imm_21=0 & S5 & imm_8_13 & imm_5_7=0b101 & alu_X5 {
        alu_X5 = alu_X5 + S5 >> imm_8_13;
        _stub();
        #TODO: chk this, might be a pair
    }

    :alu_X5"+=lsr("S5",#"imm_8_12")" is imm_22_27=0b111000 & imm_21=0 & S5 & imm_13=0 & imm_8_12 & imm_5_7=0b101 & alu_X5 {
        alu_X5 = alu_X5 + S5 >> imm_8_12;
    }
#..


}

# Shift by imm and logical
# ..
slot: "alu_X5=or(#"u8",asl("alu_X5", #"imm_8_12"))" is iclass=0b1101 & imm_24_27=0b1110 & imm_21_23 & alu_X5 & imm_13 & imm_8_12 & imm_5_7 & imm_4=0 & imm_3 & imm_1_2=0b01 & imm_0=0 [ u8 = imm_3 | (imm_5_7 << 1) | (imm_13 << 4) | (imm_21_23 << 5); ] {
    alu_X5 = u8 | (alu_X5 << imm_8_12);
}


duplex:"duplex_0x0" is imm_29_31=0b000 & imm_13=0 {
}
duplex:"duplex_0x1" is imm_29_31=0b000 & imm_13=1 {
}
duplex:"duplex_0x2" is imm_29_31=0b001 & imm_13=0 {
}
duplex:"duplex_0x3" is imm_29_31=0b001 & imm_13=1 {
}
duplex:"duplex_0x4" is imm_29_31=0b010 & imm_13=0 {
}
duplex:"duplex_0x5" is imm_29_31=0b010 & imm_13=1 {
}
duplex:"duplex_0x6" is imm_29_31=0b011 & imm_13=0 {
}
duplex:"duplex_0x7" is imm_29_31=0b011 & imm_13=1 {
}
duplex:"duplex_0x8" is imm_29_31=0b100 & imm_13=0 {
}
duplex:"duplex_0x9" is imm_29_31=0b100 & imm_13=1 {
}
duplex:"duplex_0xa" is imm_29_31=0b101 & imm_13=0 {
}
duplex:"duplex_0xb" is imm_29_31=0b101 & imm_13=1 {
}
duplex:"duplex_0xc" is imm_29_31=0b110 & imm_13=0 {
}
duplex:"duplex_0xd" is imm_29_31=0b110 & imm_13=1 {
}
duplex:"duplex_0xe" is imm_29_31=0b111 & imm_13=0 {
}
duplex:"duplex_0xf" is imm_29_31=0b111 & imm_13=1 {
}

slot0: slot is slot &  (parse=0b01 | parse=0b10) { build slot; }
slot1: slot0 is slot0 { build slot0; }
slot2: slot0 is slot0 { build slot0; }
slotX: slot is slot & parse=0b11  { build slot; }
slotX: duplex is duplex & parse=0b00  { build duplex; }

:{ slot0 slot1 slotX } is slot0;slot1;slotX {
	build slot0;
	build slot1;
	build slotX;
}
:{ slot0 slot1 slot2 slotX } is slot0;slot1;slot2;slotX {
	build slot0;
	build slot1;
	build slot2;
	build slotX;
}

#:{{ slot0 }} is slot0 {
#build slot0;
#}

:{ slotX } is slotX {
	build slotX;
} 

#define register offset=0x00 size=1 [ Rd ];

#define register offset=0x00 size=2 [ AF  BC  DE  HL ];
#define register offset=0x20 size=1 [ A_ F_ B_ C_ D_ E_ H_ L_ ]; # Alternate registers
#define register offset=0x20 size=2 [ AF_   BC_   DE_   HL_ ]; # Alternate registers

#define register offset=0x40 size=2 [ _  PC SP IX IY ];

#define register offset=0x50 size=1 [ rCBAR rCBR rBBR ];

# Define context bits (if defined, size must be multiple of 4-bytes)
#define register offset=0xf0 size=4   contextreg;

#define context contextreg
  #assume8bitIOSpace		= (0,0)
#;

# Flag bits (?? manual is very confusing - could be typos!)
#@define C_flag "F[0,1]"		# C: Carry
#@define N_flag "F[1,1]"		# N: Add/Subtract
#@define PV_flag "F[2,1]"	# PV: Parity/Overflow
#@define H_flag "F[4,1]"		# H: Half Carry
#@define Z_flag "F[6,1]"		# Z: Zero
#@define S_flag "F[7,1]"		# S: Sign

# Include contents of skel.sinc file
#@include "skel.sinc"
